---
html:
  embed_local_images: true
  embed_svg: true
  offline: false
  toc: false
title: "性能测试工具设计文档"
author: "朱自强"
---
@import "blank.md"
<!-- 修改此处标题 -->
# 性能测试工具设计文档 {.center}


<!-- pagebreak -->

<!-- 目录 -->
@import "catalog.md"

<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=4 orderedList=false} -->
<!-- code_chunk_output -->

* [1. 简述](#H-1)
* [2. 测试工具](#H-2)
	* [2.1 接口类型](#H-2-1)
	* [2.2 输出信息](#H-2-2)
	* [2.3 关于并发](#H-2-3)
	* [2.4 关于策略](#H-2-4)
	* [2.5 关于音频](#H-2-5)
		* [2.5.1 音频数据来源](#H-2-5-1)
		* [2.5.2 一次发送](#H-2-5-2)
		* [2.5.3 分片发送](#H-2-5-3)
		* [2.5.4 处理方式](#H-2-5-4)
		* [2.5.5 解码和编码](#H-2-5-5)
		* [2.5.6 音频的要求](#H-2-5-6)
	* [2.6 关于结果类型](#H-2-6)
	* [2.7 请求参数、音频数据、文本结果的组合方式](#H-2-7)
* [3.  策略 ](#H-3)
	* [3.1 简述](#H-3-1)
	* [3.2 典型的策略](#H-3-2)
		* [3.2.1  发送策略 ](#H-3-2-1)
		* [3.2.2  调用策略 ](#H-3-2-2)
	* [3.3 配置文件](#H-3-3)
		* [3.3.1 策略的表示](#H-3-3-1)
		* [3.3.2 请求参数](#H-3-3-2)
		* [3.3.3 环境信息](#H-3-3-3)
	* [3.4 示例配置](#H-3-4)
* [4. 类设计](#H-4)
	* [4.1 概览](#H-4-1)
	* [4.2 数据流转](#H-4-2)
	* [4.3 框架类](#H-4-3)
	* [4.4 数据类](#H-4-4)
	* [4.5 数据输出类](#H-4-5)
	* [4.6 可运行程序](#H-4-6)
	* [4.7 优化](#H-4-7)
	* [4.8 优化二](#H-4-8)
* [5. UML图](#H-5)
	* [5.1 类图](#H-5-1)
	* [5.2 序列图](#H-5-2)
* [6. 分析工具](#H-6)
	* [6.1 典型的性能指标](#H-6-1)
	* [6.2 问题](#H-6-2)
		* [6.2.1 问题一](#H-6-2-1)

<!-- /code_chunk_output -->
<!-- pagebreak -->

## 1. 简述 {#H-1}

本文档是`性能测试工具`的设计文档。

针对于`10.x`产品，需要获取产品的性能。

获取产品性能的典型方式
- 通过计算各模块的资源消耗，来获取产品的性能指标，
- 通过显式的调用，模拟实际调用，来获取产品的性能指标。

本文档说明如何使用**第二种方式**，也即模拟实际调用，来获取产品的性能指标。

模拟实际请求必须有一个客户端程序
此文档也是这个客户端程序的设计文档
用于说明客户端程序的实现原理和操作方式

客户端程序记录请求的时间信息
也即是，只产生了一系列的结果数据
还需要对结果数据进行分析
从而获取性能指标的具体值

此文档也说明结果数据的分析方式
以及性能指标的含义

下文中，在没有歧义的情况下
客户端程序称作`测试工具`
结果分析程序称作`分析工具`

`性能测试工具`包含`测试工具`和`分析工具`

## 2. 测试工具 {#H-2}

### 2.1 接口类型 {#H-2-1}

`测试工具`适用的接口类型
- `API`接口，调用待测产品的`API`接口，也即是调用一个库的接口
- `URL`接口，调用待测产品的网络协议接口，典型的有，`HTTP`接口，`Socket`接口，`WebSocket`接口


### 2.2 输出信息 {#H-2-2}

`测试工具`的输出是每次请求的`时间信息`
包含
- 音频时间信息
- 音频数据发送完成时刻的时间信息
- 中间结果时间信息
- 最终结果时间信息
- `VAD`事件及其时间信息


### 2.3 关于并发 {#H-2-3}

一个线程作为一个`调用者`，启用多个线程进行测试，用来模拟多个`调用者`*同时*调用的场景。
在每个线程中进行*一次测试*或持续进行*多次测试*，模拟用户实际的调用

> *同时*
作为时间点，表示时间差非常小
作为时间范围，表示有相当大的重叠范围

> *一次测试*
对于一个线程，指将其指定的请求全部发送出去并获取所有的结果
对于所有线程，指将所有线程的指定的请求全部发送出去并获取所有结果
所以，**请根据上下文来确定*一次测试*的含义**

### 2.4 关于策略 {#H-2-4}

策略，也即是调用方式，也称为测试策略
策略规定了数据发送方式和`调用者`协作方式

详细描述见[策略](#policy)。

### 2.5 关于音频 {#H-2-5}

#### 2.5.1 音频数据来源 {#H-2-5-1}

待测的音频目录中存在一个或多个音频文件
将所有音频文件合并成一个`音频流`

通过[发送策略](#send_policy)获取`音频流`中的某一段
此段的长度、起始位置、音频格式都是从配置文件中获取的

音频格式可能有`原始音频格式`和`请求音频格式`

接口中区分音频发送方式，一般有两种：一次发送，分片发送

#### 2.5.2 一次发送 {#H-2-5-2}

一次请求就完成了一次测试，所需要的音频数据也是从音频流中截取

#### 2.5.3 分片发送 {#H-2-5-3}

对于这种发送发送，音频流的使用方式是显而易见的

#### 2.5.4 处理方式 {#H-2-5-4}

测试工具中使用统一的音频处理方式
将所有音频合并成一个音频流，不考虑原始音频的大小

对于两种音频发送方式，发送策略可以使用相同的处理方式，并且配置也是相同的
不同的地方是
一次发送的音频片的长度可能大于分片发送的长度
一次发送的音频片数只能是1，分片发送的音频片数是其它正整数

#### 2.5.5 解码和编码 {#H-2-5-5}

如果音频文件中有带格式的，那么需要解码和编码
一般压缩的音频文件都是带格式的

如果需要不同的压缩和编码格式的音频作为音频源，那么也需要解码和编码

对于一次测试，它的每一个分片应当属于某一个完整格式音频

这里需要有实时的编解码处理

典型场景即是

对于一次发送，从音频流中获取一段音频后，执行编码，然后将编码后数据发送出去

对于分片发送，从音频流中获取所有音频后，
**<font color=Red> 具体方式还不太清楚 </font>**
<font color=Blue>
一个猜想的方式是
设置编码格式
传入一片音频，获取对应的编码后的数据
那么，编码信息在哪里获取到的呢
这个应该是实时流的编码
应当是不同于对音频文件的编码的

Blue Sky -- Blue Dream -- Rhapsody in Blue
</font>

#### 2.5.6 音频的要求 {#H-2-5-6}

`音频目录`中的`音频`应该保证足够长
并且需要`弱相关性`

`弱相关性`
也即是所有音频中的`任意两个发音`应当有尽可能大的差异
对应到文字上来看
出现的`字数`应该尽可能多
出现的`词数`应该尽可能多
常见字，常见词，常用语句，这些也应该都有体现

就汉字的个数来说，常用3000字，组合成的常用词，也是相当多
按照语速每秒7字计算，按照总词数一百万计算
那么总共有14万秒的音频
对于测试应该足够的多了

> 1 hour = 3600 second
  1 day  = 24 hour = 86400 second
  30 day = 720 hour = 2592000 second


问题
如何寻找足够丰富的音频
方法，使用TTS技术生成音频
然后加上环境噪声，环境噪声是实际采集，而不是计算机生成的
或者进行一些其它的数字信号处理

### 2.6 关于结果类型 {#H-2-6}

对于一段话
其结果类型有*临时结果*和*固化结果*
而且可能返回多个*临时结果*
第一个临时结果称为*首个临时结果*
也有可能直接得到*固化结果*
在返回的结果中有一个标识来表明其结果类型

> 性能测试不关心具体的结果，也即是忽略结果中的文本内容~~和结果状态（成功或失败）~~。

结果类型请参考接口的开发手册。

### 2.7 请求参数、音频数据、文本结果的组合方式 {#H-2-7}

请求参数、音频数据、识别结果的组合方式

根据请求参数和音频数据的组合方式，和识别结果的接收方式
有以下几种组合方式

方式一
先发送请求参数
而后每次请求只发送音频数据
在某个时刻收到识别结果

单次发送请求参数，分片音频，异步接收结果

方式二
每次请求都发送请求参数和音频数据
在某个时刻收到识别结果

每次请求都发送参数和音频，异步接收结果

方式三
先发送请求参数
而后每次请求只发送音频数据
每次请求等待识别结果
一次请求可能有识别结果，可能无识别结果

单次发送请求参数，分片音频，同步等待结果

方式四
每次请求都发送请求参数和音频数据
每次请求等待识别结果
一次请求可能有识别结果，可能无识别结果

每次请求都发送参数和音频，同步等待结果


> 不同的接口适用不同的方式


## 3. <span id="policy"> 策略 </span> {#H-3}

### 3.1 简述 {#H-3-1}

`策略`是指`生成`以及`发送`数据的`规则`

使用方式
- 配置文件中列出`策略`
- 程序解析`策略`，并按照`策略`发送`请求`

`策略`包含[发送策略](#send_policy)和[调用策略](#invoke_policy)

`数据`包含`请求参数`和`音频数据`

- `请求参数`包含的内容需参考对应的开发手册
`请求参数`一般也在`配置文件`中指定
也可在`接口类`中实现
`请求参数`包含`请求参数名(key)`和`请求参数值(value)`，一般同时出现

- `音频数据`即是一片音频
策略中包含音频片的大小和总片数，以及音频片发送的先后顺序


### 3.2 典型的策略 {#H-3-2}

#### 3.2.1 <span id="send_policy"> 发送策略 </span> {#H-3-2-1}

使用例子说明`发送策略`

**例子**
假设音频长度是`10秒`，每次发送`1秒`的音频数据，需要`10次请求`
以下是几种`发送策略`

`平凡的`
按照顺序发送`1 2 3 4 5 6 7 8 9 10`十个请求
`1请求`发送`音频流`的`第1秒`的数据，依此类推

`乱序的`
`1-5 8-10 6-7`
表示先按照顺序发送`1 2 3 4 5`五个请求
然后再按照顺序发送`8 9 10`三个请求
最后再按照顺序发送`6 7`两个请求
`1请求`发送`音频流`的`第1秒`的数据，依此类推

复杂一点
`1-5 8-10 5-7`
这里发送了两次`5请求`
也就是将`第5秒`的数据发送了两次，并且这两次的`请求参数`也相同

再复杂一点
`1-5 8-10 5-7`
`TTTTF TTT TTT`
`T`表示发送的`请求参数`是正常的
`F`表示发送的`请求参数`是异常的
它们所在的位置对应当前请求的`请求参数`的状态
以上表示，`1 2 3 4 6 7 8 9 10`请求发送的是正常的`请求参数`
第一次`5请求`发送的是**异常**的`请求参数`
第二次`5请求`发送的是**正常**的`请求参数`


#### 3.2.2 <span id="invoke_policy"> 调用策略 </span> {#H-3-2-2}

使用例子说明`调用策略`

**例子**
假设有`10个调用者`，每个`调用者`有一个`发送策略`
以下是几种`调用策略`

`平凡的`
每个`调用者`的`发送策略`相同
`发送策略`都是`平凡的`

`阶梯的`
`1-5 30 6-7 20 8-10 10`
表示`1 2 3 4 5`调用者发送`30次请求`
`6 7调用者`发送`20次请求`
`8 9 10调用者`发送`10次请求`

复杂一点
`1-5 30 6-7 20 8-10 10`
`1-5 30 6-7 40 8-10 50`
一行表示`一次测试`
第一行的所有请求结束后再执行第二行的测试
每一行都是一种 `阶梯的` `调用策略`

再复杂一点
将`调用者`分组，并按组分配`发送策略`
此处使用`结构化语言`描述，比如`json`
在以下描述中，定义了一些`发送策略`、`调用者组`、`调用策略`

```json {.line-numbers}
{
	"send_policy": [
		{
			"id":"0",
			"request_limit":"0",
			"duration_limit":"0",
			"slice_duration":"1000",
			"sequence":"0-0"
		},
		{
			"id":"1",
			"request_limit":"30",
			"sequence":"1-10 15-20 11-14 21-30",
		},
		{
			"id":"2",
			"request_limit":"20",
			"sequence":"1-10 15-20 11-14",
		},
		{
			"id":"3",
			"request_limit":"10",
		},
		{
			"id":"4",
			"request_limit":"40",
		},
		{
			"id":"5",
			"request_limit":"50",
		}
	],
	"invoker_group": [
		{
			"id":"1",
			"member":"1-5",
			"send_policy_id":"1"
		},
		{
			"invoker_group_id":"2",
			"member":"6-7",
			"send_policy_id":"2"
		},
		{
			"invoker_group_id":"3",
			"member":"8-10",
			"send_policy_id":"3"
		},
		{
			"invoker_group_id":"4",
			"member":"6-7",
			"send_policy_id":"4"
		},
		{
			"invoker_group_id":"5",
			"member":"8-10",
			"send_policy_id":"5"
		}
	],
	"invoke_policy":[
		{
			"id":"1",
			"invoker_group_ids":"1 2 3"
		},
		{
			"id":"2",
			"invoker_group_ids":"1 4 5"
		}
	]
	
}

```

一个`调用策略`相当于`一次测试`
`调用策略`包含一个或多个`调用者组`，`调用者组`没有先后顺序，需要同时执行
`调用者组`中的`调用者`之间也没有先后顺序，需要同时执行
每个`调用者组`都有一个[发送策略](#send_policy)
也即是，每个`调用者`都有一个[发送策略](#send_policy)

在上面的例子中
`send_policy`中，`id=0`是默认的`发送策略`
其它的覆盖`id=0`中对应项的值

`invoke_policy`中，
先执行`id=1`的所有`调用者`的请求
`id=1`完成后，再执行`id=2`的所有`调用者`的请求


> 注意，在上面的例子中并没有对每次请求的`请求参数`进行描述



### 3.3 配置文件 {#H-3-3}

配置文件中包含`策略`、`请求参数`、`环境信息`

#### 3.3.1 策略的表示 {#H-3-3-1}

`调用策略`
`一次测试`的规则
`一次测试`包含若干个`调用者组`
配置文件中可能包含多个`调用策略`
也就是进行`多次测试`

`调用者组`
对`调用者`进行分组
每个`调用者组`包含一个或多个`调用者`
一个`调用者组`指定一个`发送策略`

`调用者`
每个`调用者`相当于`一个用户`，独立执行对服务端的请求

[发送策略](#send_policy)
对数据的发送的规定

#### 3.3.2 请求参数 {#H-3-3-2}

**具体需要查看接口的开发者手册**

一般有，`addpunc`，`textpostproc`，`capkey`，`property`，`audioformat`，`domain`，
`audio_channel`，`vadhead`，`vadtail` 等等

有些参数需要实时生成的，不需要在配置文件中写明，
比如，`index`，`start_time`，`identify`，`signature` 等

#### 3.3.3 环境信息 {#H-3-3-3}

`接口地址`
如果使用`API接口`，那么此参数的值可能为空
接口类中包含了大部分的接口调用函数
API接口也有可能用到URL地址，作为函数的参数进行传递

如果使用`URL接口`，那么此参数就是一个地址
此文档的描述只适用于通用协议
对于框架协议不太适用

`音频目录`
保存音频的目录



### 3.4 示例配置 {#H-3-4}

```json {.line-numbers}
{
	"send_policy": [
		{
			"id":"0",
			"request_limit":"30",
			"duration_limit":"0",
			"slice_duration":"1000",
			"sequence":"0-0"
		}
	],
	"invoker_group": [
		{
			"id":"1",
			"member":"1-10",
			"send_policy_id":"0"
		}
	],
	"invoke_policy":[
		{
			"id":"1",
			"invoker_group_ids":"1"
		}
	],
	"parameter":[
		{
			"type":"header",
			"addpunc":"yes",
			"audioformat":"pcm8k16bit"
		},
		{
			"type":"env",
			"URL":"http://ip:port/recognize",
			"audiodir":"$HOME/audio"
		}
	]
}
```
此`策略`表示有10个`调用者`
每个`调用者`发送30个请求，每个`音频片`长度是1秒


## 4. 类设计 {#H-4}

> 参考文档
`AICP_10.x_ASR服务_需求文档.html`
`AICP_10.x_MVP_0.1_需求文档.html`
`Freetalk业务及通用模块详细设计.html`
`AICP_10.x_ASR_HTTP开发手册.html`
`AICP_10.x_ASR_WebSocket开发手册.html`

> 为避免歧义，使用`抽象类`说明`C++的基类`，而不使用`接口类`，

> `接口类`在以下的含义是`接口`的`抽象类`的`实现类`
`接口抽象类`表示接口的`抽象类`
`接口`表示`API接口`和`URL接口`


### 4.1 概览 {#H-4-1}

基本关系说明

- 全局有多个输出出口
- 全局有多个调用策略

- 每个调用策略有多个调用者
- 每个调用者只有一个发送接口
- 每个调用者只有一个发送策略

- 发送接口标识，根据标识实例化对象
- 发送策略标识，根据标识实例化对象
- 输出出口标识，根据标识实例化对象

- 调用者组概念只存在于配置中
- 发送接口有同步和异步标识
- 发送策略包含策略生成，数据生成

- 策略生成器从配置的策略生成一个数字序列
- 数据生成器按照序列生成音频
- 数据生成器也生成请求参数

- 工厂模式生产发送接口、发送策略、输出出口
- 工厂模式生产时间信息


### 4.2 数据流转 {#H-4-2}

| Module      | init        | in         | out        |
| ----------- | ----------- | ---------- | ---------- |
| SendPolicy  | ConfigSlice | NULL       | AudioInfo  |
| AudioStream | ConfigSlice | AudioInfo  | AudioPiece |
| Sender      | ConfigSlice | AudioPiece | Timestamp  |
| Output      | ConfigSlice | Timestamp  | NULL       |

### 4.3 框架类 {#H-4-3}

`框架类`中包含`配置解析类`和`调用策略类`

`配置解析类`生成`调用策略类`的对象
`调用策略类`即是一个线程，运行此线程启用`调用者`
并等待所有`调用者`执行完毕

> **是否支持多个接口**
这里设计时，支持多个接口
在一次测试中可以使用多个接口同时测试

> **是否支持动态修改配置参数**
这里设计时，不支持动态修改配置参数
修改配置参数后需要重启测试程序

`调用者类`成员中有`接口类`、`发送策略类`、`数据输出类`


### 4.4 数据类 {#H-4-4}

这里是需要输出的数据
`数据类`包含
- `请求数据类`，也即`音频信息类`，每一次请求都产生一个此类的对象
- `时间信息类`，一次请求中的不同时刻和不同结果的时间信息

`时间信息类`有
- `分片音频的时间信息类`
- `请求时刻的实现信息类`
- `临时结果的时间信息类`
- `固化结果的时间信息类`
- `VAD状态和时间信息类`

### 4.5 数据输出类 {#H-4-5}

> Q 是否需要实时保存结果信息
A 需要实时保存结果信息

`调用者类`将结果信息放到`数据输出类`中
`数据输出类`读取结果信息并将其写入磁盘

这里需要同步和通知操作
使用互斥量和信号量
每产生一条数据，就将其写入磁盘


### 4.6 可运行程序 {#H-4-6}

一个可运行的程序中
包含以下实现
`配置解析类`，一个
`调用策略类`，一个
`调用者类`，一个
`接口类`，一个或多个
`发送策略类`，一个或多个
`数据类`，多个
`数据输出类`，一个或多个


### 4.7 优化 {#H-4-7}

如果需要很多的`调用者`，那么需要创建很多个线程

可以将线程和`调用者`分离
使用固定数量的线程
每个线程执行多个`调用者`

通常可以这样
获取`CPU`的核数，一般使用逻辑核，即为`CoreCount`
启动`CoreCount`个线程
每个线程分配一定的`调用者`，可以使用平均分配
在线程中将所有`调用者`的请求都发送出去
使用多路复用等待结果的返回

这样之后

`调用策略类`中包含`线程类`和`调用者类`
`线程类`的对象的个数根据具体机器环境确定
`调用者类`的对象的个数根据配置的参数的值确定

按照目前`CPU`的`PIPELINE`特性，可以启用`CoreCount*4`个线程

### 4.8 优化二 {#H-4-8}

`测试工具`和`分析工具`的协作

上面描述的是`分析工具`读取`测试工具`写入磁盘的数据
是对结果数据的`非实时分析`

如果需要实时获取当前的性能指标
那么对上述传递方式简单修改也能达到需求

所谓简单修改，是指
写入磁盘时候执行flush
`分析工具`持续的读取文件中的内容

而这里说的优化是使用进程间通信的方式传递数据
典型的可以使用`socket`
如此之后，可以将`测试工具`和`分析工具`部署在不同的机器上
也可以接入其它的`分析工具`来获取更丰富的指标
并可以实时的获取性能指标



## 5. UML图 {#H-5}

### 5.1 类图 {#H-5-1}

```plantuml {.line-numbers .center}

class Config
class InvokePolicy
class Invoker

interface ISendPolicy
class SendPolicy

interface ISender
class Sender

interface IDataOutput
class DataOutput

interface Timestamp
class AudioTimestamp
class SendTimestamp
class InternalResultTimestamp
class FinalResultTimestamp
class VadInfoTimestamp

Config  "1" --* "0..n" InvokePolicy
Config --> IDataOutput

InvokePolicy "1" --* "0..n" Invoker

Invoker "1" -right-* "1" ISender
Invoker "1" -right-* "1" ISendPolicy

IDataOutput --> Timestamp
Invoker --> Timestamp

Invoker -right-> IDataOutput

Timestamp <|-- AudioTimestamp
Timestamp <|-- SendTimestamp
Timestamp <|-- InternalResultTimestamp
Timestamp <|-- FinalResultTimestamp
Timestamp <|-- VadInfoTimestamp

Sender --|> ISender
SendPolicy --|> ISendPolicy
DataOutput --|> IDataOutput

class Config{
	+ InvokePolicy[] invokepolicys
	+ Json json

	+ string filename
}

class InvokePolicy {
	+ Invoker[] invokers

	+ void Run()
	+ void Stop()
	+ void WaitInvokers()
}

class Invoker {
	+ int request_limit
	+ int duration_limit
	+ int invoker_number

	+ ISender sender
	+ ISendPolicy sendpolicy

	+ void Run()
	+ void Stop()
	+ void WaitAudio()

	+ int tid
}

interface ISender {
	+ int send()

	+ string url
	- void construct()
}

interface ISendPolicy {
	+ AudioData GetAudioData()
	+ RequestParam GetRequestParam()
}


interface IDataOutput{
	+ std::shared_ptr<DataConsistence> Instance(const string & fname)
	+ Run()
	+ Stop()

	+ int Push(Timestamp& timestamp)

	- DataConsistence()

	- std::atomic<bool> status
	- std::mutex mtx
	- std::condition_variable cv

	+ std::string filename
	+ std::ofstream ostrm
}



```


### 5.2 序列图 {#H-5-2}






------------------------------------------
以下内容放入到UML图中
操作流程

`调用者类`中
调用`数据输出类`的 `PUSH` 函数

此函数执行以下操作：
- 获取`数据输出类`的锁
- 将此条`数据类`信息写入到`数据输出类`中
- 释放`数据输出类`的锁
- 通知`数据输出类`操作

`数据输出类`中

`big while`
- 获取`数据输出类`的锁
- 如果没有数据，则等待
- 获取数据
- 释放`数据数据类`的锁
- 写入磁盘
-------------------------------------





-----------------------------------
以下内容放入到UML图


`调用者类`的执行流程为
初始化
- 调用配置解析类成员解析配置
- 调用策略解析类成员获取策略

`big while`
- `调用策略类`的成员生产待发送内容
- 产生`数据类`的对象（`分片音频的时间信息类`）
  调用`数据输出类`的成员保存数据类的对象
- 调用`接口类`的成员执行发送
- 产生`数据类`的对象（`请求时刻的实现信息类`）
  调用`数据输出类`的成员保存数据类的对象
- 调用`接口类`的成员获取结果
- 产生`数据类`的对象（`临时结果或固化结果的时间信息类`）
  调用`数据输出类`的成员保存`数据类`的对象

--------------------------------



## 6. 分析工具 {#H-6}


`分析工具`是对`测试工具`的输出的分析
也就是读取`测试工具`产生的文本内容


`分析工具`的输出是性能指标
包含
- 并发数
- `DPS`
- 临时结果延时
- 固化结果延时
- 其它指标

见典型的性能指标



### 6.1 典型的性能指标 {#H-6-1}

- 并发数：实际测试时设置的并发线程数量 
- `DPS`：每秒可处理的音频时长
  计算方式：一个时间段内完成的所有请求的音频文件总时长除以这个时间段的长度
- 临时结果延时: 一次请求中发完音频数据和收到*首个临时结果*的时间差
  计算方式：收到每段话首个临时结果的时间戳减去对应音频数据首次送入时的时间戳
- 固化结果延时: 一次请求中发完音频数据和收到*固化结果*的时间差
  计算方式：获得固化结果时的时间戳减去固化结果对应音频数据完全送入引擎/服务时的时间戳
- 对于其中的延时，还应计算出，最小值，最大值，`TP50`, `TP90`, `TP95`, `TP99`

这些表示一组指标，是相关联的，
进行多次测试，针对于不同的设置，可得出不同的具体值。
性能指标中的值，是分析工具的输出。

### 6.2 问题 {#H-6-2}

#### 6.2.1 问题一 {#H-6-2-1}

上面的`临时结果延时`有歧义
`临时结果`指一段话没确定时的结果

`临时结果延时`
- 可以是每次请求和`首个临时结果`的时间差，此时，一段话中可能有多个`临时结果延时`，并且此延时的数值是递增的
- 也可以是每次请求中的时间差，此时，一段话中可能有多个`临时结果延时`
- 也可以是首个请求中的时间差，此时，一段话中只有一个`临时结果延时`

同时，如果一个音频中有多段话，那么就会有多个`临时结果延时`

请求数和音频数
不使用音频数，合并所有音频，使用请求数统一说明和管理需要发送的音频
